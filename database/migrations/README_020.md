# Миграция 020-022: Система нормализации адресов

**Дата:** 2025-11-21
**Автор:** Claude AI
**Связанные миграции:** 020, 021, 022

## Обзор

Эта серия миграций реализует систему нормализации адресов для заявок. Позволяет привязывать заявки с произвольно введенными адресами к формализованному справочнику адресов города с помощью fuzzy поиска.

## Проблема

В системе заявок абоненты указывают адреса в произвольной форме:
- "Ленина 5"
- "ул.Ленина д5"
- "Lenin st 5"

Все эти варианты описывают один и тот же адрес, но выглядят по-разному. Это создает проблемы:
- Невозможно группировать заявки по реальному адресу
- Сложно вести статистику по адресам
- Нет связи с техническими узлами подключения

## Решение

### Архитектура

**Двухуровневая модель адресов:**

1. **Свободный адрес** (`street_and_house` в `zakaz_applications`)
   - Вводится абонентом/менеджером при создании заявки
   - Хранится "как есть" для истории
   - Может содержать опечатки и нестандартное написание

2. **Формализованный адрес** (`zakaz_addresses`)
   - Справочник всех адресов города
   - Структурированные поля: `street`, `house`
   - Единственный источник правды для группировки

3. **Статус привязки** (`address_match_status`)
   - `unmatched` - адрес не привязан к справочнику
   - `manual_matched` - адрес привязан вручную менеджером
   - `auto_matched` - резерв для будущего автоматического поиска

### Рабочий процесс

```
1. Абонент звонит → Менеджер создает заявку с адресом в свободной форме
   ↓
2. При просмотре заявки менеджер видит: "Не привязан к формализованному адресу"
   ↓
3. Менеджер нажимает "Привязать" → Открывается мастер поиска адресов
   ↓
4. Система автоматически ищет похожие адреса (fuzzy search)
   ↓
5. Менеджер выбирает правильный адрес → Привязка сохранена
   ↓
6. Все заявки с этим формализованным адресом теперь группируются вместе
```

## Технические детали

### Миграция 020: Добавление статуса привязки

```sql
CREATE TYPE address_match_status AS ENUM ('unmatched', 'auto_matched', 'manual_matched');

ALTER TABLE zakaz_applications
  ADD COLUMN address_match_status address_match_status DEFAULT 'unmatched' NOT NULL;
```

**Что делает:**
- Создает enum тип для статуса привязки
- Добавляет поле `address_match_status` в таблицу заявок
- Обновляет существующие заявки (если address_id заполнен → 'manual_matched')
- Создает индекс для быстрого поиска непривязанных заявок

### Миграция 021: Индексы для fuzzy поиска

```sql
CREATE EXTENSION IF NOT EXISTS pg_trgm;

CREATE INDEX idx_addresses_street_trgm
  ON zakaz_addresses USING gin(street gin_trgm_ops);
```

**Что делает:**
- Устанавливает расширение `pg_trgm` (триграммы) для нечеткого поиска
- Создает GIN индекс для быстрого fuzzy поиска по улице
- Создает обычные индексы для точного поиска по дому

**Как работает fuzzy search:**
- PostgreSQL разбивает строку на триграммы (последовательности из 3 символов)
- Пример: "Ленина" → ["Лен", "ени", "нин", "ина"]
- При поиске "Ленна" → ["Лен", "енн", "нна"] → находит похожие строки
- Возвращает результаты с коэффициентом схожести (similarity)

### Миграция 022: Функция поиска

```sql
CREATE FUNCTION search_addresses_fuzzy(search_query TEXT)
RETURNS TABLE (id, street, house, similarity, ...)
```

**Что делает:**
- Создает PostgreSQL функцию для нечеткого поиска адресов
- Ищет по улице, дому и их комбинации
- Возвращает до 20 наиболее похожих адресов
- Сортирует по убыванию схожести (similarity DESC)

## API изменения

### Новый endpoint: GET /api/addresses/search

**Запрос:**
```
GET /api/addresses/search?query=ленина+5
```

**Ответ:**
```json
{
  "addresses": [
    {
      "id": "uuid",
      "street": "ул. Ленина",
      "house": "5",
      "similarity": 0.85,
      "full_address": "ул. Ленина, 5"
    }
  ]
}
```

### Обновленный endpoint: PATCH /api/applications/:id

**Новые поля:**
```json
{
  "address_id": "uuid",
  "address_match_status": "manual_matched"
}
```

## UI изменения

### 1. Карточка заявки

Добавлен блок "Формализованный адрес":

**Если привязан:**
```
Формализованный адрес: ✓ ул. Ленина, 5 [Изменить]
```

**Если не привязан:**
```
Статус: ⚠ Не привязан к формализованному адресу [Привязать]
```

### 2. Мастер привязки адресов (обновлен)

**Изменения:**
- Вместо загрузки всех адресов → использует fuzzy search API
- Debounce для поиска (300ms)
- Индикатор загрузки при поиске
- Отображение коэффициента схожести
- Автоматический поиск при открытии по адресу из заявки

## Применение миграций

### Вручную через psql:

```bash
psql -U your_user -d your_database -f database/migrations/020_add_address_match_status.sql
psql -U your_user -d your_database -f database/migrations/021_add_address_search_indexes.sql
psql -U your_user -d your_database -f database/migrations/022_create_address_search_function.sql
```

### Через Supabase Dashboard:

1. Перейти в SQL Editor
2. Скопировать содержимое каждой миграции
3. Выполнить по порядку (020 → 021 → 022)

## Тестирование

### 1. Проверка расширения pg_trgm:

```sql
SELECT * FROM pg_extension WHERE extname = 'pg_trgm';
```

### 2. Проверка индексов:

```sql
SELECT * FROM pg_indexes WHERE tablename = 'zakaz_addresses';
```

### 3. Тестирование fuzzy search:

```sql
-- Должен найти "ул. Ленина" даже с опечаткой
SELECT * FROM search_addresses_fuzzy('Ленна 5');

-- Проверка similarity
SELECT
  street,
  similarity(street, 'Ленина') as sim
FROM zakaz_addresses
ORDER BY sim DESC
LIMIT 5;
```

### 4. Проверка UI:

1. Создать заявку с адресом "Ленина 5"
2. Открыть карточку заявки
3. Проверить, что отображается "Не привязан..."
4. Нажать "Привязать"
5. Проверить, что мастер открылся и показал похожие адреса
6. Привязать адрес
7. Проверить, что статус изменился на "Формализованный адрес: ✓ ..."

## Откат (Rollback)

Если нужно откатить миграции:

```sql
-- Откат 022
DROP FUNCTION IF EXISTS search_addresses_fuzzy(TEXT);

-- Откат 021
DROP INDEX IF EXISTS idx_addresses_street_trgm;
DROP INDEX IF EXISTS idx_addresses_house;
DROP INDEX IF EXISTS idx_addresses_street_house;
DROP EXTENSION IF EXISTS pg_trgm;

-- Откат 020
DROP INDEX IF EXISTS idx_applications_match_status;
ALTER TABLE zakaz_applications DROP COLUMN address_match_status;
DROP TYPE IF EXISTS address_match_status;
```

## Будущие улучшения

### Фаза 2 (опционально):

1. **Автоматическая привязка при создании**
   - При создании заявки сразу предлагать похожие адреса
   - Если similarity > 0.8 → автоматически привязывать

2. **Таблица маппингов**
   - Создать `zakaz_address_mappings`
   - Хранить историю вариантов написания
   - Обучать систему: "ул Ленина 5" всегда → "ул. Ленина, 5"

3. **Статистика**
   - Дашборд непривязанных адресов
   - Список самых частых вариантов написания
   - Автоматические предложения для пакетной привязки

4. **Интеграция с ФИАС**
   - Загрузка справочника адресов из ФИАС
   - Автоматическая нормализация по ФИАС API

## Производительность

**Ожидаемая нагрузка:** 20 заявок в день

**Индексы:**
- GIN индекс `idx_addresses_street_trgm`: ~2-3 MB для 10000 адресов
- Обычные индексы: минимальный overhead

**Скорость поиска:**
- Без индексов: ~50-100ms для 10000 адресов (seq scan)
- С GIN индексом: ~2-5ms (index scan)

**Рекомендации:**
- При росте справочника до 100k+ адресов рассмотреть партиционирование
- Monitoring: следить за размером индексов и временем выполнения search_addresses_fuzzy()

## Безопасность

- Все изменения логируются в `zakaz_audit_log`
- Изменение привязки требует роли `manager` или выше
- SQL injection защита: используются prepared statements

## Поддержка

При возникновении проблем проверить:

1. Установлено ли расширение pg_trgm
2. Созданы ли индексы (запрос выше)
3. Есть ли данные в zakaz_addresses
4. Логи Supabase при выполнении search_addresses_fuzzy()

## Changelog

- **2025-11-21**: Начальная реализация (миграции 020-022)

---

## Обновление (Миграция 023): Гибридный поиск адресов

**Дата:** 2025-11-21  
**Связанные миграции:** 023

### Новая архитектура: Ленивая загрузка адресов

Вместо предварительной загрузки всех 50,000+ адресов города, система теперь использует **гибридный подход**:

#### Как это работает:

1. **При поиске адреса в мастере:**
   - Сначала ищем в локальной БД (`zakaz_addresses`) через fuzzy search
   - Если найдено < 3 результатов → дополнительный запрос к КЛАДР API
   - Показываем объединенные результаты с пометкой источника

2. **При выборе адреса:**
   - Если адрес из локальной БД → привязываем сразу
   - Если адрес из КЛАДР API → сначала сохраняем в `zakaz_addresses`, потом привязываем

3. **Результат:**
   - База растет органически только с используемыми адресами
   - Нет необходимости в предзагрузке 50,000+ адресов
   - Быстрый fuzzy search на компактной БД
   - Доступ ко всем адресам города через API

#### Технические детали:

**Миграция 023:**
```sql
-- Добавлен уникальный constraint для предотвращения дубликатов
ALTER TABLE zakaz_addresses
  ADD CONSTRAINT zakaz_addresses_street_house_unique
  UNIQUE (street, house);
```

**API изменения:**

1. **GET /api/addresses/search** (обновлен)
   - Гибридный поиск: локально + КЛАДР API
   - Возвращает `source: 'local' | 'external'`
   - Статистика: `{ local: N, external: M, total: K }`

2. **POST /api/addresses/save-external** (новый)
   - Сохраняет внешний адрес в локальную БД
   - Предотвращает дубликаты через UNIQUE constraint
   - Вызывается автоматически при выборе внешнего адреса

**UI изменения:**

- Адреса из КЛАДР API помечены бейджем "КЛАДР" (синий)
- Локальные адреса без бейджа
- Подсказка: "Будет сохранен в локальную базу при выборе"

#### Преимущества:

✅ **Нет предзагрузки** - база не перегружена  
✅ **Органический рост** - только реально используемые адреса  
✅ **Быстрый поиск** - fuzzy search на маленькой БД  
✅ **Полный охват** - доступ ко всем адресам через КЛАДР  
✅ **Кеширование** - КЛАДР API результаты кешируются на 1 час  

#### Примеры использования:

**Сценарий 1: Популярный адрес**
```
1. Менеджер ищет "Ленина 5"
2. Найдено в локальной БД (был привязан ранее)
3. Выбирает → привязывается мгновенно
4. ⚡ Быстро (fuzzy search в локальной БД)
```

**Сценарий 2: Новый адрес**
```
1. Менеджер ищет "Бердская 10"
2. Не найдено локально → запрос к КЛАДР API
3. Найдено в КЛАДР (бейдж "КЛАДР")
4. Выбирает → сохраняется в БД → привязывается
5. В следующий раз этот адрес уже в локальной БД
```

**Сценарий 3: Опечатка**
```
1. Менеджер ищет "Ленна 5" (опечатка)
2. Fuzzy search находит "Ленина 5" в локальной БД
3. Similarity = 0.85 (высокая схожесть)
4. Выбирает правильный вариант
```

#### Мониторинг:

Отслеживать рост базы адресов:

```sql
-- Статистика роста базы
SELECT
  COUNT(*) as total_addresses,
  COUNT(DISTINCT street) as unique_streets,
  MAX(created_at) as last_added
FROM zakaz_addresses;

-- Топ-10 самых используемых адресов
SELECT
  a.street,
  a.house,
  COUNT(app.id) as applications_count
FROM zakaz_addresses a
LEFT JOIN zakaz_applications app ON app.address_id = a.id
GROUP BY a.id, a.street, a.house
ORDER BY applications_count DESC
LIMIT 10;
```

#### Настройка:

Порог для запроса к КЛАДР API можно настроить в `/app/api/addresses/search/route.ts`:

```typescript
const MIN_LOCAL_RESULTS = 3 // Если меньше 3 результатов → запрос к КЛАДР
```

#### Откат миграции 023:

```sql
ALTER TABLE zakaz_addresses
  DROP CONSTRAINT zakaz_addresses_street_house_unique;
```

---

## Changelog

- **2025-11-21**: Миграции 020-022 - Начальная реализация fuzzy search
- **2025-11-21**: Миграция 023 - Гибридный поиск с КЛАДР API и ленивая загрузка
